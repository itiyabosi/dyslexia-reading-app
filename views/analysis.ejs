<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ»æˆç¸¾è¡¨</title>
  <link rel="stylesheet" href="/css/style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    .chart-container {
      position: relative;
      height: 300px;
      margin: 20px 0;
    }
    .report-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 10px;
      margin-bottom: 30px;
      text-align: center;
    }
    .print-btn {
      background-color: #9C27B0;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px;
    }
    .print-btn:hover {
      background-color: #7B1FA2;
    }
    @media print {
      nav, .print-btn { display: none; }
      .card { page-break-inside: avoid; }
    }
  </style>
</head>
<body>
  <header>
    <h1>ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ»æˆç¸¾è¡¨</h1>
    <div style="position: absolute; top: 10px; right: 20px; font-size: 12px; color: rgba(255,255,255,0.7);">
      <%= commitHash %>
    </div>
  </header>

  <div class="container">
    <nav>
      <div class="nav-links">
          <a href="/">ãƒ›ãƒ¼ãƒ </a>
        <a href="/word-lists">å˜èªãƒªã‚¹ãƒˆç®¡ç†</a>
        <a href="/analysis">ãƒ‡ãƒ¼ã‚¿åˆ†æ</a>
        <a href="/fonts">ãƒ•ã‚©ãƒ³ãƒˆç®¡ç†</a>
      </div>
        <a href="/logout" class="logout-btn">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</a>
    </nav>

    <div class="card">
      <h2>å…ç«¥ã‚’é¸æŠ</h2>
      <% if (children.length === 0) { %>
        <p>å…ç«¥ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>
      <% } else { %>
        <select id="childSelector" class="form-group" style="width: 100%; padding: 12px; font-size: 16px;">
          <option value="">å…ç«¥ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
          <% children.forEach(child => { %>
            <option value="<%= child.id %>" data-name="<%= child.name %>" data-grade="<%= child.grade || '' %>"><%= child.name %><%= child.grade ? ' (' + child.grade + ')' : '' %></option>
          <% }) %>
        </select>
      <% } %>
    </div>

    <div id="statsArea" style="display: none;">

      <div class="report-header">
        <h2 style="margin: 0; font-size: 32px;" id="reportTitle">éŸ³éŸ»èªè­˜ãƒ†ã‚¹ãƒˆ æˆç¸¾è¡¨</h2>
        <p style="margin: 10px 0 0 0; font-size: 18px;" id="reportSubtitle"></p>
        <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;" id="reportDate"></p>
      </div>

      <div style="text-align: center; margin-bottom: 20px;">
        <button class="print-btn" onclick="window.print()">ğŸ“„ å°åˆ·ãƒ»PDFä¿å­˜</button>
      </div>

      <div class="card">
        <h2>ğŸ“Š ç·åˆçµ±è¨ˆ</h2>
        <div class="stats-grid">
          <div class="stat-card">
            <h3 id="totalTests">-</h3>
            <p>ãƒ†ã‚¹ãƒˆå®Ÿæ–½å›æ•°</p>
          </div>
          <div class="stat-card" style="background-color: #e8f5e9;">
            <h3 id="successfulReads" style="color: #388E3C;">-</h3>
            <p>èª­ã‚ãŸå˜èªæ•°</p>
          </div>
          <div class="stat-card" style="background-color: #fff3e0;">
            <h3 id="avgTime" style="color: #F57C00;">-</h3>
            <p>å¹³å‡èª­ã¿æ™‚é–“ï¼ˆç§’ï¼‰</p>
          </div>
          <div class="stat-card" style="background-color: #ffebee;">
            <h3 id="misreadCount" style="color: #D32F2F;">-</h3>
            <p>èª­ã¿é–“é•ã„å›æ•°</p>
          </div>
        </div>

        <div class="stats-grid">
          <div class="stat-card" style="background-color: #e1f5fe;">
            <h3 id="successRate" style="color: #0277BD;">-</h3>
            <p>æ­£ç­”ç‡</p>
          </div>
          <div class="stat-card" style="background-color: #f3e5f5;">
            <h3 id="fastestTime" style="color: #6A1B9A;">-</h3>
            <p>æœ€é€Ÿèª­ã¿æ™‚é–“ï¼ˆç§’ï¼‰</p>
          </div>
          <div class="stat-card" style="background-color: #fce4ec;">
            <h3 id="slowestTime" style="color: #C2185B;">-</h3>
            <p>æœ€é…èª­ã¿æ™‚é–“ï¼ˆç§’ï¼‰</p>
          </div>
          <div class="stat-card" style="background-color: #e8eaf6;">
            <h3 id="testDays" style="color: #3949AB;">-</h3>
            <p>ãƒ†ã‚¹ãƒˆå®Ÿæ–½æ—¥æ•°</p>
          </div>
        </div>

        <div class="stats-grid">
          <div class="stat-card" style="background-color: #e0f2f1;">
            <h3 id="consistencyScore" style="color: #00796B;">-</h3>
            <p>ä¸€è²«æ€§ã‚¹ã‚³ã‚¢</p>
          </div>
          <div class="stat-card" style="background-color: #fff8e1;">
            <h3 id="learningSlope" style="color: #F9A825;">-</h3>
            <p>å­¦ç¿’æ›²ç·šã®å‚¾ã</p>
          </div>
          <div class="stat-card" style="background-color: #fbe9e7;">
            <h3 id="bestFont" style="color: #D84315;">-</h3>
            <p>æœ€é©ãƒ•ã‚©ãƒ³ãƒˆ</p>
          </div>
          <div class="stat-card" style="background-color: #f1f8e9;">
            <h3 id="improvementRate" style="color: #689F38;">-</h3>
            <p>ç·åˆæ”¹å–„ç‡</p>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>ğŸ“Š å˜èªãƒªã‚¹ãƒˆåˆ¥æ­£ç­”ç‡</h2>
        <p style="color: #666; margin-bottom: 15px;">å„å˜èªã‚»ãƒƒãƒˆã§ã®æ­£ç­”ç‡ã¨è©³ç´°çµ±è¨ˆ</p>
        <div id="wordSetAccuracyTable"></div>
      </div>

      <div class="card">
        <h2>ğŸ”¤ ãƒ•ã‚©ãƒ‹ãƒƒã‚¯ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ</h2>
        <p style="color: #666; margin-bottom: 15px;">åˆé ­å­éŸ³ãƒ»æ¯éŸ³ãƒ»èªå°¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç¿’å¾—çŠ¶æ³ï¼ˆè‹¦æ‰‹ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã¯èµ¤è‰²è¡¨ç¤ºï¼‰</p>
        <div id="phonicsAnalysisTable"></div>
      </div>

      <div class="card">
        <h2>ğŸµ ãƒ©ã‚¤ãƒ ï¼ˆéŸ»ï¼‰åˆ†æ</h2>
        <p style="color: #666; margin-bottom: 15px;">å˜èªã®éŸ»ï¼ˆèªå°¾ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ã®ç¿’å¾—çŠ¶æ³ï¼ˆè‹¦æ‰‹ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã¯èµ¤è‰²è¡¨ç¤ºï¼‰</p>
        <div id="rimeAnalysisTable"></div>
      </div>

      <div class="card">
        <h2>â±ï¸ èª­ã¿æ™‚é–“ã®æ¨ç§»</h2>
        <div class="chart-container">
          <canvas id="timeChart"></canvas>
        </div>
      </div>

      <div class="card">
        <h2>ğŸ“Š èª­ã¿æ™‚é–“ã®æ”¹å–„ãƒˆãƒ¬ãƒ³ãƒ‰ï¼ˆ5å›ç§»å‹•å¹³å‡ï¼‰</h2>
        <div class="chart-container">
          <canvas id="improvementTrendChart"></canvas>
        </div>
      </div>

      <div class="card">
        <h2>ğŸ¯ å˜èªåˆ¥ é€Ÿåº¦æ”¹å–„ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h2>
        <p style="color: #666; margin-bottom: 15px;">å„å˜èªã®åˆå›ã¨æœ€æ–°ã®èª­ã¿æ™‚é–“ã‚’æ¯”è¼ƒï¼ˆ2å›ä»¥ä¸Šãƒ†ã‚¹ãƒˆã—ãŸå˜èªã®ã¿ï¼‰</p>
        <div id="wordImprovementTable"></div>
      </div>

      <div class="card" style="background-color: #fff3e0;">
        <h2>âš ï¸ æ”¹å–„ãŒå¿…è¦ãªå˜èªï¼ˆè¦æ³¨æ„ãƒªã‚¹ãƒˆï¼‰</h2>
        <p style="color: #666; margin-bottom: 15px;">æ”¹å–„ãŒè¦‹ã‚‰ã‚Œãªã„ã€ã¾ãŸã¯èª­ã¿æ™‚é–“ãŒé•·ããªã£ã¦ã„ã‚‹å˜èª</p>
        <div id="needsImprovementTable"></div>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <div class="card">
          <h2>âœ… æ­£ç­”ç‡ã®å†…è¨³</h2>
          <div class="chart-container">
            <canvas id="successPieChart"></canvas>
          </div>
        </div>

        <div class="card">
          <h2>ğŸ“š å˜èªãƒªã‚¹ãƒˆåˆ¥æˆç¸¾</h2>
          <div class="chart-container">
            <canvas id="wordListChart"></canvas>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>ğŸ”¤ ãƒ•ã‚©ãƒ³ãƒˆåˆ¥æˆç¸¾æ¯”è¼ƒ</h2>
        <p style="color: #666; margin-bottom: 15px;">å„ãƒ•ã‚©ãƒ³ãƒˆã§ã®æ­£ç­”ç‡ã¨å¹³å‡èª­ã¿æ™‚é–“ã‚’æ¯”è¼ƒ</p>
        <div class="chart-container" style="height: 400px;">
          <canvas id="fontComparisonChart"></canvas>
        </div>
      </div>

      <div class="card">
        <h2>ğŸ“Š ãƒ•ã‚©ãƒ³ãƒˆåˆ¥è©³ç´°çµ±è¨ˆ</h2>
        <div id="fontStatsTable"></div>
      </div>

      <div class="card">
        <h2>ğŸ“‹ è©³ç´°ãƒ†ã‚¹ãƒˆå±¥æ­´</h2>
        <div id="recordsTable"></div>
      </div>
    </div>
  </div>

  <script>
    const childSelector = document.getElementById('childSelector');
    const statsArea = document.getElementById('statsArea');
    let charts = {}; // ã‚°ãƒ©ãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒ

    childSelector.addEventListener('change', async (e) => {
      const childId = e.target.value;

      if (!childId) {
        statsArea.style.display = 'none';
        return;
      }

      const selectedOption = e.target.options[e.target.selectedIndex];
      const childName = selectedOption.dataset.name;
      const childGrade = selectedOption.dataset.grade;

      // ãƒ¬ãƒãƒ¼ãƒˆãƒ˜ãƒƒãƒ€ãƒ¼æ›´æ–°
      document.getElementById('reportTitle').textContent = childName + ' ã•ã‚“ã®æˆç¸¾è¡¨';
      document.getElementById('reportSubtitle').textContent = childGrade ? 'ï¼ˆ' + childGrade + 'ï¼‰' : '';
      document.getElementById('reportDate').textContent = 'ä½œæˆæ—¥: ' + new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' });

      const response = await fetch('/api/analysis/' + childId);
      const data = await response.json();

      // çµ±è¨ˆè¡¨ç¤º
      document.getElementById('totalTests').textContent = data.stats.total_tests || 0;
      document.getElementById('successfulReads').textContent = data.stats.successful_reads || 0;
      document.getElementById('avgTime').textContent = data.stats.avg_time ? data.stats.avg_time.toFixed(2) : '-';
      document.getElementById('misreadCount').textContent = data.stats.misread_count || 0;

      // è¿½åŠ çµ±è¨ˆ
      const successRate = data.stats.total_tests > 0
        ? ((data.stats.successful_reads / data.stats.total_tests) * 100).toFixed(1)
        : 0;
      document.getElementById('successRate').textContent = successRate + '%';

      // æœ€é€Ÿãƒ»æœ€é…æ™‚é–“ã®è¨ˆç®—
      const times = data.records.filter(r => r.reading_time_seconds).map(r => r.reading_time_seconds);
      document.getElementById('fastestTime').textContent = times.length > 0 ? Math.min(...times).toFixed(2) : '-';
      document.getElementById('slowestTime').textContent = times.length > 0 ? Math.max(...times).toFixed(2) : '-';

      // ãƒ†ã‚¹ãƒˆå®Ÿæ–½æ—¥æ•°ï¼ˆã‚µãƒ¼ãƒãƒ¼å´ã§è¨ˆç®—æ¸ˆã¿ï¼‰
      document.getElementById('testDays').textContent = data.stats.test_days || 0;

      // æ–°æ©Ÿèƒ½: ä¸€è²«æ€§ã‚¹ã‚³ã‚¢
      const consistencyScore = calculateConsistencyScore(data.records);
      document.getElementById('consistencyScore').textContent = consistencyScore;

      // æ–°æ©Ÿèƒ½: å­¦ç¿’æ›²ç·šã®å‚¾ã
      const learningSlope = calculateLearningSlope(data.records);
      document.getElementById('learningSlope').textContent = learningSlope;

      // æ–°æ©Ÿèƒ½: ãƒ•ã‚©ãƒ³ãƒˆåˆ¥çµ±è¨ˆ
      const fontStats = calculateFontStats(data.records);
      const bestFont = findBestFont(fontStats);
      document.getElementById('bestFont').textContent = bestFont;

      // æ–°æ©Ÿèƒ½: ç·åˆæ”¹å–„ç‡
      const improvementRate = calculateImprovementRate(data.records);
      document.getElementById('improvementRate').textContent = improvementRate;

      // ã‚°ãƒ©ãƒ•æç”»
      drawCharts(data);

      // ãƒ†ã‚¹ãƒˆå±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«
      drawRecordsTable(data.records);

      // æ–°ã—ã„åˆ†ææ©Ÿèƒ½
      drawImprovementAnalysis(data.records);

      // ãƒ•ã‚©ãƒ³ãƒˆåˆ¥åˆ†æ
      drawFontComparison(data.records, fontStats);

      // ãƒ•ã‚©ãƒ‹ãƒƒã‚¯ã‚¹ãƒ»ãƒ©ã‚¤ãƒ åˆ†æ
      drawPhonicsAnalysis(data.records);
      drawRimeAnalysis(data.records);

      statsArea.style.display = 'block';
    });

    function drawCharts(data) {
      // æ—¢å­˜ã®ã‚°ãƒ©ãƒ•ã‚’ç ´æ£„
      Object.values(charts).forEach(chart => chart.destroy());
      charts = {};

      // 1. å˜èªãƒªã‚¹ãƒˆåˆ¥æ­£ç­”ç‡ãƒ†ãƒ¼ãƒ–ãƒ«
      drawWordSetAccuracyTable(data.records);

      // 2. èª­ã¿æ™‚é–“ã®æ¨ç§»ï¼ˆæŠ˜ã‚Œç·šï¼‰
      const progressData = data.records.slice().reverse();
      const timeData = progressData.filter(r => r.reading_time_seconds);
      charts.time = new Chart(document.getElementById('timeChart'), {
        type: 'line',
        data: {
          labels: timeData.map((r, i) => (i + 1) + 'å›ç›®'),
          datasets: [{
            label: 'èª­ã¿æ™‚é–“ï¼ˆç§’ï¼‰',
            data: timeData.map(r => r.reading_time_seconds),
            borderColor: '#FF9800',
            backgroundColor: 'rgba(255, 152, 0, 0.1)',
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });

      // 2-2. èª­ã¿æ™‚é–“ã®æ”¹å–„ãƒˆãƒ¬ãƒ³ãƒ‰ï¼ˆ5å›ç§»å‹•å¹³å‡ï¼‰
      if (timeData.length >= 5) {
        const movingAverage = [];
        for (let i = 4; i < timeData.length; i++) {
          const sum = timeData.slice(i - 4, i + 1).reduce((acc, r) => acc + r.reading_time_seconds, 0);
          movingAverage.push(sum / 5);
        }

        charts.improvementTrend = new Chart(document.getElementById('improvementTrendChart'), {
          type: 'line',
          data: {
            labels: movingAverage.map((_, i) => (i + 5) + 'å›ç›®'),
            datasets: [{
              label: '5å›ç§»å‹•å¹³å‡ï¼ˆç§’ï¼‰',
              data: movingAverage,
              borderColor: '#9C27B0',
              backgroundColor: 'rgba(156, 39, 176, 0.1)',
              tension: 0.4,
              fill: true,
              borderWidth: 3
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  afterLabel: function(context) {
                    const index = context.dataIndex;
                    if (index > 0) {
                      const improvement = ((movingAverage[index - 1] - movingAverage[index]) / movingAverage[index - 1] * 100);
                      return improvement > 0
                        ? `å‰å›ã‚ˆã‚Š ${improvement.toFixed(1)}% æ”¹å–„`
                        : `å‰å›ã‚ˆã‚Š ${Math.abs(improvement).toFixed(1)}% æ‚ªåŒ–`;
                    }
                    return '';
                  }
                }
              }
            }
          }
        });
      } else {
        // ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã„å ´åˆã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
        const canvas = document.getElementById('improvementTrendChart');
        const ctx = canvas.getContext('2d');
        ctx.font = '16px sans-serif';
        ctx.fillStyle = '#999';
        ctx.textAlign = 'center';
        ctx.fillText('5å›ä»¥ä¸Šã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ã§ã™', canvas.width / 2, canvas.height / 2);
      }

      // 3. æ­£ç­”ç‡ã®å††ã‚°ãƒ©ãƒ•
      const successCount = data.stats.successful_reads || 0;
      const failCount = (data.stats.total_tests || 0) - successCount;
      charts.successPie = new Chart(document.getElementById('successPieChart'), {
        type: 'doughnut',
        data: {
          labels: ['èª­ã‚ãŸ', 'èª­ã‚ãªã‹ã£ãŸ'],
          datasets: [{
            data: [successCount, failCount],
            backgroundColor: ['#4CAF50', '#f44336']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom'
            }
          }
        }
      });

      // 4. å˜èªãƒªã‚¹ãƒˆåˆ¥æˆç¸¾ï¼ˆæ£’ã‚°ãƒ©ãƒ•ï¼‰
      const wordListStats = {};
      data.records.forEach(r => {
        if (!wordListStats[r.word_list_name]) {
          wordListStats[r.word_list_name] = { total: 0, success: 0 };
        }
        wordListStats[r.word_list_name].total++;
        if (r.could_read) wordListStats[r.word_list_name].success++;
      });

      const wordListLabels = Object.keys(wordListStats);
      const wordListSuccessRates = wordListLabels.map(label =>
        (wordListStats[label].success / wordListStats[label].total * 100).toFixed(1)
      );

      charts.wordList = new Chart(document.getElementById('wordListChart'), {
        type: 'bar',
        data: {
          labels: wordListLabels,
          datasets: [{
            label: 'æ­£ç­”ç‡ï¼ˆ%ï¼‰',
            data: wordListSuccessRates,
            backgroundColor: '#2196F3'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100
            }
          }
        }
      });
    }

    function drawRecordsTable(records) {
      const recordsTable = document.getElementById('recordsTable');

      if (records.length === 0) {
        recordsTable.innerHTML = '<p>ã¾ã ãƒ†ã‚¹ãƒˆè¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
        return;
      }

      let tableHtml = '<table><thead><tr>' +
        '<th>No.</th>' +
        '<th>æ—¥æ™‚</th>' +
        '<th>å˜èªãƒªã‚¹ãƒˆ</th>' +
        '<th>å˜èª</th>' +
        '<th>ãƒ•ã‚©ãƒ³ãƒˆ</th>' +
        '<th>çµæœ</th>' +
        '<th>èª­ã¿æ™‚é–“ï¼ˆç§’ï¼‰</th>' +
        '<th>èª­ã¿é–“é•ã„</th>' +
        '<th>å‚™è€ƒ</th>' +
        '</tr></thead><tbody>';

      records.forEach((record, index) => {
        const date = new Date(record.test_date);
        const dateStr = date.toLocaleString('ja-JP');
        const result = record.could_read ? 'âœ“ èª­ã‚ãŸ' : 'âœ— èª­ã‚ãªã‹ã£ãŸ';
        const resultStyle = record.could_read ? 'color: green; font-weight: bold;' : 'color: red; font-weight: bold;';

        tableHtml += '<tr>' +
          '<td>' + (records.length - index) + '</td>' +
          '<td>' + dateStr + '</td>' +
          '<td>' + record.word_list_name + '</td>' +
          '<td style="font-weight: bold; font-size: 18px;">' + record.word_text + '</td>' +
          '<td>' + (record.font_name || '-') + '</td>' +
          '<td style="' + resultStyle + '">' + result + '</td>' +
          '<td>' + (record.reading_time_seconds ? record.reading_time_seconds.toFixed(2) : '-') + '</td>' +
          '<td>' + (record.misread_as || '-') + '</td>' +
          '<td>' + (record.notes || '-') + '</td>' +
          '</tr>';
      });

      tableHtml += '</tbody></table>';
      recordsTable.innerHTML = tableHtml;
    }

    function drawImprovementAnalysis(records) {
      // å˜èªã”ã¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
      const wordData = {};

      records.forEach(record => {
        if (!record.reading_time_seconds) return;

        if (!wordData[record.word_text]) {
          wordData[record.word_text] = [];
        }
        wordData[record.word_text].push({
          time: record.reading_time_seconds,
          date: record.test_date,
          could_read: record.could_read
        });
      });

      // å„å˜èªã®æ”¹å–„åº¦ã‚’è¨ˆç®—ï¼ˆ2å›ä»¥ä¸Šãƒ†ã‚¹ãƒˆã—ãŸå˜èªã®ã¿ï¼‰
      const improvements = [];
      Object.keys(wordData).forEach(word => {
        const tests = wordData[word];
        if (tests.length >= 2) {
          // æ—¥ä»˜é †ã«ã‚½ãƒ¼ãƒˆ
          tests.sort((a, b) => new Date(a.date) - new Date(b.date));

          const firstTime = tests[0].time;
          const lastTime = tests[tests.length - 1].time;
          const improvementPercent = ((firstTime - lastTime) / firstTime * 100);
          const avgTime = tests.reduce((sum, t) => sum + t.time, 0) / tests.length;
          const successRate = tests.filter(t => t.could_read).length / tests.length * 100;

          improvements.push({
            word,
            firstTime,
            lastTime,
            improvementPercent,
            improvementSeconds: firstTime - lastTime,
            testCount: tests.length,
            avgTime,
            successRate
          });
        }
      });

      // æ”¹å–„åº¦ã§ã‚½ãƒ¼ãƒˆï¼ˆæ”¹å–„ãŒå¤§ãã„é †ï¼‰
      improvements.sort((a, b) => b.improvementPercent - a.improvementPercent);

      // å˜èªåˆ¥æ”¹å–„ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤º
      drawWordImprovementTable(improvements);

      // æ”¹å–„ãŒå¿…è¦ãªå˜èªï¼ˆæ”¹å–„åº¦ãŒä½ã„ã€ã¾ãŸã¯æ‚ªåŒ–ã—ã¦ã„ã‚‹ï¼‰
      const needsImprovement = improvements.filter(w => w.improvementPercent < 10).slice(0, 10);
      drawNeedsImprovementTable(needsImprovement);
    }

    function drawWordImprovementTable(improvements) {
      const container = document.getElementById('wordImprovementTable');

      if (improvements.length === 0) {
        container.innerHTML = '<p style="color: #999;">2å›ä»¥ä¸Šãƒ†ã‚¹ãƒˆã—ãŸå˜èªãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
        return;
      }

      let tableHtml = '<table><thead><tr>' +
        '<th>é †ä½</th>' +
        '<th>å˜èª</th>' +
        '<th>åˆå›ï¼ˆç§’ï¼‰</th>' +
        '<th>æœ€æ–°ï¼ˆç§’ï¼‰</th>' +
        '<th>æ”¹å–„åº¦</th>' +
        '<th>çŸ­ç¸®æ™‚é–“</th>' +
        '<th>ãƒ†ã‚¹ãƒˆå›æ•°</th>' +
        '<th>å¹³å‡æ™‚é–“</th>' +
        '<th>æ­£ç­”ç‡</th>' +
        '</tr></thead><tbody>';

      improvements.forEach((item, index) => {
        const improvementStyle = item.improvementPercent > 0
          ? 'color: green; font-weight: bold;'
          : 'color: red; font-weight: bold;';

        const improvementText = item.improvementPercent > 0
          ? `â†“ ${item.improvementPercent.toFixed(1)}%`
          : `â†‘ ${Math.abs(item.improvementPercent).toFixed(1)}%`;

        const shortenText = item.improvementSeconds > 0
          ? `âˆ’${item.improvementSeconds.toFixed(2)}ç§’`
          : `+${Math.abs(item.improvementSeconds).toFixed(2)}ç§’`;

        tableHtml += '<tr>' +
          '<td>' + (index + 1) + '</td>' +
          '<td style="font-weight: bold; font-size: 16px;">' + item.word + '</td>' +
          '<td>' + item.firstTime.toFixed(2) + '</td>' +
          '<td>' + item.lastTime.toFixed(2) + '</td>' +
          '<td style="' + improvementStyle + '">' + improvementText + '</td>' +
          '<td style="' + improvementStyle + '">' + shortenText + '</td>' +
          '<td>' + item.testCount + '</td>' +
          '<td>' + item.avgTime.toFixed(2) + '</td>' +
          '<td>' + item.successRate.toFixed(0) + '%</td>' +
          '</tr>';
      });

      tableHtml += '</tbody></table>';
      container.innerHTML = tableHtml;
    }

    function drawNeedsImprovementTable(needsImprovement) {
      const container = document.getElementById('needsImprovementTable');

      if (needsImprovement.length === 0) {
        container.innerHTML = '<p style="color: green; font-weight: bold;">âœ“ ã™ã¹ã¦ã®å˜èªã§è‰¯å¥½ãªæ”¹å–„ãŒè¦‹ã‚‰ã‚Œã¾ã™ï¼</p>';
        return;
      }

      let tableHtml = '<table><thead><tr>' +
        '<th>å˜èª</th>' +
        '<th>çŠ¶æ³</th>' +
        '<th>åˆå›ï¼ˆç§’ï¼‰</th>' +
        '<th>æœ€æ–°ï¼ˆç§’ï¼‰</th>' +
        '<th>å¤‰åŒ–</th>' +
        '<th>ãƒ†ã‚¹ãƒˆå›æ•°</th>' +
        '<th>æ­£ç­”ç‡</th>' +
        '</tr></thead><tbody>';

      needsImprovement.forEach(item => {
        let status, statusStyle;

        if (item.improvementPercent < -10) {
          status = 'âš ï¸ æ‚ªåŒ–';
          statusStyle = 'background-color: #ffebee; color: #c62828; font-weight: bold;';
        } else if (item.improvementPercent < 0) {
          status = 'âš ï¸ ã‚ãšã‹ã«æ‚ªåŒ–';
          statusStyle = 'background-color: #fff3e0; color: #e65100; font-weight: bold;';
        } else if (item.improvementPercent < 5) {
          status = 'â–³ ã»ã¼å¤‰åŒ–ãªã—';
          statusStyle = 'background-color: #fffde7; color: #f57f17;';
        } else {
          status = 'â–³ ã‚ãšã‹ã«æ”¹å–„';
          statusStyle = 'background-color: #f1f8e9; color: #558b2f;';
        }

        const changeText = item.improvementPercent > 0
          ? `${item.improvementPercent.toFixed(1)}% æ”¹å–„`
          : `${Math.abs(item.improvementPercent).toFixed(1)}% æ‚ªåŒ–`;

        tableHtml += '<tr>' +
          '<td style="font-weight: bold; font-size: 16px;">' + item.word + '</td>' +
          '<td style="' + statusStyle + '">' + status + '</td>' +
          '<td>' + item.firstTime.toFixed(2) + '</td>' +
          '<td>' + item.lastTime.toFixed(2) + '</td>' +
          '<td>' + changeText + '</td>' +
          '<td>' + item.testCount + '</td>' +
          '<td>' + item.successRate.toFixed(0) + '%</td>' +
          '</tr>';
      });

      tableHtml += '</tbody></table>';
      container.innerHTML = tableHtml;
    }

    // ========== å˜èªãƒªã‚¹ãƒˆåˆ¥æ­£ç­”ç‡ãƒ†ãƒ¼ãƒ–ãƒ« ==========
    function drawWordSetAccuracyTable(records) {
      const container = document.getElementById('wordSetAccuracyTable');

      if (records.length === 0) {
        container.innerHTML = '<p style="color: #999;">ãƒ†ã‚¹ãƒˆè¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
        return;
      }

      // å˜èªãƒªã‚¹ãƒˆã”ã¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆ
      const wordListStats = {};

      records.forEach(record => {
        const listName = record.word_list_name;

        if (!wordListStats[listName]) {
          wordListStats[listName] = {
            total: 0,
            success: 0,
            totalTime: 0,
            timeCount: 0,
            words: {}
          };
        }

        const stats = wordListStats[listName];
        stats.total++;
        if (record.could_read) {
          stats.success++;
        }
        if (record.reading_time_seconds) {
          stats.totalTime += record.reading_time_seconds;
          stats.timeCount++;
        }

        // å˜èªã”ã¨ã®çµ±è¨ˆã‚‚å–å¾—
        const word = record.word_text;
        if (!stats.words[word]) {
          stats.words[word] = {
            total: 0,
            success: 0
          };
        }
        stats.words[word].total++;
        if (record.could_read) {
          stats.words[word].success++;
        }
      });

      // ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
      let tableHtml = '<table><thead><tr>' +
        '<th>å˜èªãƒªã‚¹ãƒˆ</th>' +
        '<th>ç·ãƒ†ã‚¹ãƒˆæ•°</th>' +
        '<th>æ­£ç­”æ•°</th>' +
        '<th>æ­£ç­”ç‡</th>' +
        '<th>å¹³å‡èª­ã¿æ™‚é–“ï¼ˆç§’ï¼‰</th>' +
        '<th>å˜èªæ•°</th>' +
        '<th>å®Œå…¨ç¿’å¾—å˜èª</th>' +
        '<th>è©•ä¾¡</th>' +
        '</tr></thead><tbody>';

      Object.keys(wordListStats).forEach(listName => {
        const stats = wordListStats[listName];
        const successRate = (stats.success / stats.total * 100).toFixed(1);
        const avgTime = stats.timeCount > 0 ? (stats.totalTime / stats.timeCount).toFixed(2) : '-';

        // å®Œå…¨ç¿’å¾—å˜èªï¼ˆæ­£ç­”ç‡100%ï¼‰ã®æ•°
        const wordCount = Object.keys(stats.words).length;
        const masteredWords = Object.values(stats.words).filter(w =>
          w.success === w.total && w.total > 0
        ).length;

        // è©•ä¾¡
        let evaluation, evalStyle;
        const rate = parseFloat(successRate);
        if (rate >= 90) {
          evaluation = 'â­â­â­ å„ªç§€';
          evalStyle = 'background-color: #e8f5e9; color: #2e7d32; font-weight: bold;';
        } else if (rate >= 75) {
          evaluation = 'â­â­ è‰¯å¥½';
          evalStyle = 'background-color: #fff8e1; color: #f9a825;';
        } else if (rate >= 60) {
          evaluation = 'â­ è¦æ”¹å–„';
          evalStyle = 'background-color: #fff3e0; color: #e65100;';
        } else {
          evaluation = 'âš ï¸ è¦å¼·åŒ–';
          evalStyle = 'background-color: #ffebee; color: #c62828; font-weight: bold;';
        }

        tableHtml += '<tr>' +
          '<td style="font-weight: bold; font-size: 16px;">' + listName + '</td>' +
          '<td>' + stats.total + '</td>' +
          '<td style="color: #4CAF50; font-weight: bold;">' + stats.success + '</td>' +
          '<td style="font-weight: bold; color: #0277BD; font-size: 18px;">' + successRate + '%</td>' +
          '<td>' + avgTime + '</td>' +
          '<td>' + wordCount + '</td>' +
          '<td>' + masteredWords + ' / ' + wordCount + '</td>' +
          '<td style="' + evalStyle + '">' + evaluation + '</td>' +
          '</tr>';
      });

      tableHtml += '</tbody></table>';
      container.innerHTML = tableHtml;
    }

    // ========== æ–°æ©Ÿèƒ½: ä¸€è²«æ€§ã‚¹ã‚³ã‚¢ã®è¨ˆç®— ==========
    function calculateConsistencyScore(records) {
      // åŒã˜å˜èªã‚’è¤‡æ•°å›ãƒ†ã‚¹ãƒˆã—ãŸå ´åˆã®æ­£ç­”ç‡ã®ä¸€è²«æ€§ã‚’æ¸¬å®š
      const wordData = {};

      records.forEach(record => {
        if (!wordData[record.word_text]) {
          wordData[record.word_text] = [];
        }
        wordData[record.word_text].push(record.could_read);
      });

      // 2å›ä»¥ä¸Šãƒ†ã‚¹ãƒˆã—ãŸå˜èªã®ã¿ã‚’å¯¾è±¡
      const consistencyScores = [];
      Object.keys(wordData).forEach(word => {
        const results = wordData[word];
        if (results.length >= 2) {
          // æ¨™æº–åå·®ã‚’è¨ˆç®—
          const mean = results.reduce((sum, val) => sum + val, 0) / results.length;
          const variance = results.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / results.length;
          const stdDev = Math.sqrt(variance);

          // ä¸€è²«æ€§ã‚¹ã‚³ã‚¢ = 1 - æ¨™æº–åå·®ï¼ˆ0-1ã®ç¯„å›²ã§ã€1ã«è¿‘ã„ã»ã©ä¸€è²«æ€§ãŒé«˜ã„ï¼‰
          const consistency = 1 - stdDev;
          consistencyScores.push(consistency);
        }
      });

      if (consistencyScores.length === 0) {
        return '-';
      }

      // å…¨å˜èªã®å¹³å‡ä¸€è²«æ€§ã‚¹ã‚³ã‚¢
      const avgConsistency = consistencyScores.reduce((sum, score) => sum + score, 0) / consistencyScores.length;
      return (avgConsistency * 100).toFixed(1) + '%';
    }

    // ========== æ–°æ©Ÿèƒ½: å­¦ç¿’æ›²ç·šã®å‚¾ãã®è¨ˆç®— ==========
    function calculateLearningSlope(records) {
      // æ™‚ç³»åˆ—ã§ã®èª­ã¿æ™‚é–“ã®æ”¹å–„é€Ÿåº¦ã‚’ç·šå½¢å›å¸°ã§è¨ˆç®—
      const timeData = records
        .filter(r => r.reading_time_seconds)
        .slice()
        .reverse(); // å¤ã„é †ã«ã‚½ãƒ¼ãƒˆ

      if (timeData.length < 2) {
        return '-';
      }

      // ç·šå½¢å›å¸°: y = ax + b
      const n = timeData.length;
      const x = Array.from({ length: n }, (_, i) => i + 1); // ãƒ†ã‚¹ãƒˆå›æ•°
      const y = timeData.map(r => r.reading_time_seconds);

      const sumX = x.reduce((sum, val) => sum + val, 0);
      const sumY = y.reduce((sum, val) => sum + val, 0);
      const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);
      const sumX2 = x.reduce((sum, val) => sum + val * val, 0);

      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);

      // å‚¾ããŒè²  = æ”¹å–„ã€æ­£ = æ‚ªåŒ–
      if (slope < -0.01) {
        return 'â†“ ' + Math.abs(slope).toFixed(3) + 'ç§’/å›';
      } else if (slope > 0.01) {
        return 'â†‘ ' + slope.toFixed(3) + 'ç§’/å›';
      } else {
        return 'â†’ æ¨ªã°ã„';
      }
    }

    // ========== æ–°æ©Ÿèƒ½: ãƒ•ã‚©ãƒ³ãƒˆåˆ¥çµ±è¨ˆã®è¨ˆç®— ==========
    function calculateFontStats(records) {
      const fontData = {};

      records.forEach(record => {
        const fontName = record.font_name || 'ãƒ•ã‚©ãƒ³ãƒˆæœªæŒ‡å®š';

        if (!fontData[fontName]) {
          fontData[fontName] = {
            total: 0,
            success: 0,
            totalTime: 0,
            timeCount: 0,
            times: []
          };
        }

        fontData[fontName].total++;
        if (record.could_read) {
          fontData[fontName].success++;
        }
        if (record.reading_time_seconds) {
          fontData[fontName].totalTime += record.reading_time_seconds;
          fontData[fontName].timeCount++;
          fontData[fontName].times.push(record.reading_time_seconds);
        }
      });

      // çµ±è¨ˆã‚’è¨ˆç®—
      Object.keys(fontData).forEach(fontName => {
        const data = fontData[fontName];
        data.successRate = (data.success / data.total * 100).toFixed(1);
        data.avgTime = data.timeCount > 0 ? (data.totalTime / data.timeCount).toFixed(2) : null;

        // ä¸­å¤®å€¤ã‚’è¨ˆç®—
        if (data.times.length > 0) {
          const sorted = data.times.slice().sort((a, b) => a - b);
          const mid = Math.floor(sorted.length / 2);
          data.medianTime = sorted.length % 2 === 0
            ? ((sorted[mid - 1] + sorted[mid]) / 2).toFixed(2)
            : sorted[mid].toFixed(2);
        } else {
          data.medianTime = null;
        }
      });

      return fontData;
    }

    // ========== æ–°æ©Ÿèƒ½: æœ€é©ãƒ•ã‚©ãƒ³ãƒˆã®åˆ¤å®š ==========
    function findBestFont(fontStats) {
      const fonts = Object.keys(fontStats);

      if (fonts.length === 0) {
        return '-';
      }

      // æ­£ç­”ç‡ãŒæœ€ã‚‚é«˜ã„ãƒ•ã‚©ãƒ³ãƒˆã‚’é¸æŠï¼ˆåŒç‡ã®å ´åˆã¯èª­ã¿æ™‚é–“ãŒçŸ­ã„æ–¹ï¼‰
      let bestFont = fonts[0];
      let bestScore = parseFloat(fontStats[bestFont].successRate);
      let bestTime = fontStats[bestFont].avgTime ? parseFloat(fontStats[bestFont].avgTime) : Infinity;

      fonts.forEach(fontName => {
        const score = parseFloat(fontStats[fontName].successRate);
        const time = fontStats[fontName].avgTime ? parseFloat(fontStats[fontName].avgTime) : Infinity;

        if (score > bestScore || (score === bestScore && time < bestTime)) {
          bestFont = fontName;
          bestScore = score;
          bestTime = time;
        }
      });

      return bestFont;
    }

    // ========== æ–°æ©Ÿèƒ½: ç·åˆæ”¹å–„ç‡ã®è¨ˆç®— ==========
    function calculateImprovementRate(records) {
      const timeData = records
        .filter(r => r.reading_time_seconds)
        .slice()
        .reverse(); // å¤ã„é †ã«ã‚½ãƒ¼ãƒˆ

      if (timeData.length < 2) {
        return '-';
      }

      // åˆå›10å›ï¼ˆã¾ãŸã¯å…¨ä½“ã®å‰åŠï¼‰ã¨æœ€æ–°10å›ï¼ˆã¾ãŸã¯å…¨ä½“ã®å¾ŒåŠï¼‰ã‚’æ¯”è¼ƒ
      const splitPoint = Math.floor(timeData.length / 2);
      const firstHalf = timeData.slice(0, splitPoint);
      const secondHalf = timeData.slice(splitPoint);

      const firstAvg = firstHalf.reduce((sum, r) => sum + r.reading_time_seconds, 0) / firstHalf.length;
      const secondAvg = secondHalf.reduce((sum, r) => sum + r.reading_time_seconds, 0) / secondHalf.length;

      const improvementPercent = ((firstAvg - secondAvg) / firstAvg * 100);

      if (improvementPercent > 0) {
        return 'â†“ ' + improvementPercent.toFixed(1) + '%';
      } else if (improvementPercent < 0) {
        return 'â†‘ ' + Math.abs(improvementPercent).toFixed(1) + '%';
      } else {
        return 'â†’ 0%';
      }
    }

    // ========== æ–°æ©Ÿèƒ½: ãƒ•ã‚©ãƒ³ãƒˆåˆ¥ã‚°ãƒ©ãƒ•æç”» ==========
    function drawFontComparison(records, fontStats) {
      const fontNames = Object.keys(fontStats);

      if (fontNames.length === 0) {
        document.getElementById('fontStatsTable').innerHTML = '<p style="color: #999;">ãƒ•ã‚©ãƒ³ãƒˆæƒ…å ±ãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>';
        return;
      }

      // ãƒ•ã‚©ãƒ³ãƒˆåˆ¥ã‚°ãƒ©ãƒ•ï¼ˆè¤‡åˆã‚°ãƒ©ãƒ•: æ­£ç­”ç‡ã¨å¹³å‡èª­ã¿æ™‚é–“ï¼‰
      const successRates = fontNames.map(name => parseFloat(fontStats[name].successRate));
      const avgTimes = fontNames.map(name => fontStats[name].avgTime ? parseFloat(fontStats[name].avgTime) : 0);

      charts.fontComparison = new Chart(document.getElementById('fontComparisonChart'), {
        type: 'bar',
        data: {
          labels: fontNames,
          datasets: [
            {
              label: 'æ­£ç­”ç‡ï¼ˆ%ï¼‰',
              data: successRates,
              backgroundColor: 'rgba(76, 175, 80, 0.6)',
              borderColor: 'rgba(76, 175, 80, 1)',
              borderWidth: 2,
              yAxisID: 'y'
            },
            {
              label: 'å¹³å‡èª­ã¿æ™‚é–“ï¼ˆç§’ï¼‰',
              data: avgTimes,
              backgroundColor: 'rgba(255, 152, 0, 0.6)',
              borderColor: 'rgba(255, 152, 0, 1)',
              borderWidth: 2,
              type: 'line',
              yAxisID: 'y1'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              beginAtZero: true,
              max: 100,
              title: {
                display: true,
                text: 'æ­£ç­”ç‡ï¼ˆ%ï¼‰'
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              beginAtZero: true,
              title: {
                display: true,
                text: 'å¹³å‡èª­ã¿æ™‚é–“ï¼ˆç§’ï¼‰'
              },
              grid: {
                drawOnChartArea: false
              }
            }
          },
          plugins: {
            legend: {
              position: 'top'
            }
          }
        }
      });

      // ãƒ•ã‚©ãƒ³ãƒˆåˆ¥è©³ç´°çµ±è¨ˆãƒ†ãƒ¼ãƒ–ãƒ«
      drawFontStatsTable(fontStats);
    }

    // ========== æ–°æ©Ÿèƒ½: ãƒ•ã‚©ãƒ³ãƒˆåˆ¥çµ±è¨ˆãƒ†ãƒ¼ãƒ–ãƒ« ==========
    function drawFontStatsTable(fontStats) {
      const container = document.getElementById('fontStatsTable');
      const fontNames = Object.keys(fontStats);

      if (fontNames.length === 0) {
        container.innerHTML = '<p style="color: #999;">ãƒ•ã‚©ãƒ³ãƒˆæƒ…å ±ãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>';
        return;
      }

      // æ­£ç­”ç‡ã§ã‚½ãƒ¼ãƒˆï¼ˆé™é †ï¼‰
      fontNames.sort((a, b) => parseFloat(fontStats[b].successRate) - parseFloat(fontStats[a].successRate));

      let tableHtml = '<table><thead><tr>' +
        '<th>é †ä½</th>' +
        '<th>ãƒ•ã‚©ãƒ³ãƒˆå</th>' +
        '<th>ãƒ†ã‚¹ãƒˆå›æ•°</th>' +
        '<th>æ­£ç­”ç‡</th>' +
        '<th>å¹³å‡èª­ã¿æ™‚é–“</th>' +
        '<th>ä¸­å¤®å€¤</th>' +
        '<th>è©•ä¾¡</th>' +
        '</tr></thead><tbody>';

      fontNames.forEach((fontName, index) => {
        const data = fontStats[fontName];
        const successRate = parseFloat(data.successRate);

        // è©•ä¾¡ã®åˆ¤å®š
        let evaluation, evalStyle;
        if (successRate >= 80) {
          evaluation = 'â­â­â­ å„ªç§€';
          evalStyle = 'background-color: #e8f5e9; color: #2e7d32; font-weight: bold;';
        } else if (successRate >= 60) {
          evaluation = 'â­â­ è‰¯å¥½';
          evalStyle = 'background-color: #fff8e1; color: #f9a825;';
        } else if (successRate >= 40) {
          evaluation = 'â­ è¦æ”¹å–„';
          evalStyle = 'background-color: #fff3e0; color: #e65100;';
        } else {
          evaluation = 'âš ï¸ ä¸é©åˆ';
          evalStyle = 'background-color: #ffebee; color: #c62828; font-weight: bold;';
        }

        tableHtml += '<tr>' +
          '<td>' + (index + 1) + '</td>' +
          '<td style="font-weight: bold; font-size: 16px;">' + fontName + '</td>' +
          '<td>' + data.total + '</td>' +
          '<td style="font-weight: bold; color: #0277BD;">' + data.successRate + '%</td>' +
          '<td>' + (data.avgTime || '-') + 'ç§’</td>' +
          '<td>' + (data.medianTime || '-') + 'ç§’</td>' +
          '<td style="' + evalStyle + '">' + evaluation + '</td>' +
          '</tr>';
      });

      tableHtml += '</tbody></table>';
      container.innerHTML = tableHtml;
    }

    // ========== ãƒ•ã‚©ãƒ‹ãƒƒã‚¯ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ ==========
    function extractPhonicsPatterns(word) {
      if (!word) return [];
      word = word.toLowerCase();

      const patterns = [];

      // åˆé ­å­éŸ³ãƒ‘ã‚¿ãƒ¼ãƒ³
      const initialConsonants = [
        'bl', 'br', 'ch', 'cl', 'cr', 'dr', 'fl', 'fr', 'gh', 'gl', 'gr',
        'ph', 'pl', 'pr', 'sc', 'sh', 'sk', 'sl', 'sm', 'sn', 'sp', 'st',
        'sw', 'th', 'tr', 'tw', 'wh', 'wr'
      ];

      for (const pattern of initialConsonants) {
        if (word.startsWith(pattern)) {
          patterns.push(pattern + '-');
          break;
        }
      }

      if (patterns.length === 0 && word.length > 0 && /[bcdfghjklmnpqrstvwxyz]/.test(word[0])) {
        patterns.push(word[0] + '-');
      }

      // æ¯éŸ³ãƒ‘ã‚¿ãƒ¼ãƒ³
      const vowelPatterns = ['ai', 'ay', 'ea', 'ee', 'ie', 'oa', 'oe', 'oo', 'ou', 'ow', 'ue', 'ui'];
      for (const pattern of vowelPatterns) {
        if (word.includes(pattern)) {
          patterns.push('-' + pattern + '-');
        }
      }

      // å˜ä¸€æ¯éŸ³
      if (!patterns.some(p => p.includes('-') && p.length > 2)) {
        const singleVowels = word.match(/[aeiou]/g);
        if (singleVowels && singleVowels.length > 0) {
          patterns.push('-' + singleVowels[0] + '-');
        }
      }

      // èªå°¾ãƒ‘ã‚¿ãƒ¼ãƒ³
      const endings = ['ck', 'ng', 'nk', 'ed', 'er', 'est', 'ing', 'le', 'ly', 'tion', 'sion'];
      for (const pattern of endings) {
        if (word.endsWith(pattern)) {
          patterns.push('-' + pattern);
          break;
        }
      }

      return patterns;
    }

    function extractRime(word) {
      if (!word || word.length < 2) return null;
      word = word.toLowerCase();

      // ä¸€èˆ¬çš„ãªãƒ©ã‚¤ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ¯éŸ³+å­éŸ³ã§çµ‚ã‚ã‚‹ï¼‰
      const rimeMatch = word.match(/([aeiou][a-z]*)$/);
      if (rimeMatch && rimeMatch[1].length >= 2) {
        return '-' + rimeMatch[1];
      }

      return null;
    }

    function drawPhonicsAnalysis(records) {
      const container = document.getElementById('phonicsAnalysisTable');

      if (!records || records.length === 0) {
        container.innerHTML = '<p style="color: #999;">ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
        return;
      }

      // ãƒ•ã‚©ãƒ‹ãƒƒã‚¯ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã”ã¨ã®çµ±è¨ˆã‚’é›†è¨ˆ
      const phonicsStats = {};

      records.forEach(record => {
        const word = record.word_text;
        const patterns = extractPhonicsPatterns(word);
        const success = record.could_read === 1;

        patterns.forEach(pattern => {
          if (!phonicsStats[pattern]) {
            phonicsStats[pattern] = { total: 0, success: 0 };
          }
          phonicsStats[pattern].total++;
          if (success) phonicsStats[pattern].success++;
        });
      });

      // æ­£ç­”ç‡ã‚’è¨ˆç®—ã—ã¦ã‚½ãƒ¼ãƒˆ
      const phonicsArray = Object.keys(phonicsStats).map(pattern => ({
        pattern: pattern,
        total: phonicsStats[pattern].total,
        success: phonicsStats[pattern].success,
        rate: (phonicsStats[pattern].success / phonicsStats[pattern].total * 100).toFixed(1)
      })).sort((a, b) => parseFloat(a.rate) - parseFloat(b.rate));

      if (phonicsArray.length === 0) {
        container.innerHTML = '<p style="color: #999;">ãƒ•ã‚©ãƒ‹ãƒƒã‚¯ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚</p>';
        return;
      }

      // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
      let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px;">';

      phonicsArray.forEach(item => {
        const rate = parseFloat(item.rate);
        let bgColor, textColor;

        if (rate < 50) {
          bgColor = '#ffcdd2'; // èµ¤
          textColor = '#c62828';
        } else if (rate < 70) {
          bgColor = '#ffe0b2'; // ã‚ªãƒ¬ãƒ³ã‚¸
          textColor = '#e65100';
        } else if (rate < 90) {
          bgColor = '#fff9c4'; // é»„è‰²
          textColor = '#f57f17';
        } else {
          bgColor = '#c8e6c9'; // ç·‘
          textColor = '#2e7d32';
        }

        html += `
          <div style="
            background-color: ${bgColor};
            border: 2px solid ${textColor};
            border-radius: 8px;
            padding: 15px;
            text-align: center;
          ">
            <div style="font-size: 24px; font-weight: bold; color: ${textColor}; margin-bottom: 8px;">
              ${item.pattern}
            </div>
            <div style="font-size: 28px; font-weight: bold; color: ${textColor}; margin-bottom: 5px;">
              ${item.rate}%
            </div>
            <div style="font-size: 12px; color: #666;">
              ${item.success}/${item.total}å›æ­£è§£
            </div>
          </div>
        `;
      });

      html += '</div>';
      container.innerHTML = html;
    }

    function drawRimeAnalysis(records) {
      const container = document.getElementById('rimeAnalysisTable');

      if (!records || records.length === 0) {
        container.innerHTML = '<p style="color: #999;">ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
        return;
      }

      // ãƒ©ã‚¤ãƒ ã”ã¨ã®çµ±è¨ˆã‚’é›†è¨ˆ
      const rimeStats = {};

      records.forEach(record => {
        const word = record.word_text;
        const rime = extractRime(word);
        const success = record.could_read === 1;

        if (rime) {
          if (!rimeStats[rime]) {
            rimeStats[rime] = { total: 0, success: 0, words: [] };
          }
          rimeStats[rime].total++;
          if (success) rimeStats[rime].success++;
          if (!rimeStats[rime].words.includes(word)) {
            rimeStats[rime].words.push(word);
          }
        }
      });

      // æ­£ç­”ç‡ã‚’è¨ˆç®—ã—ã¦ã‚½ãƒ¼ãƒˆ
      const rimeArray = Object.keys(rimeStats).map(rime => ({
        rime: rime,
        total: rimeStats[rime].total,
        success: rimeStats[rime].success,
        rate: (rimeStats[rime].success / rimeStats[rime].total * 100).toFixed(1),
        words: rimeStats[rime].words.slice(0, 3).join(', ')
      })).sort((a, b) => parseFloat(a.rate) - parseFloat(b.rate));

      if (rimeArray.length === 0) {
        container.innerHTML = '<p style="color: #999;">ãƒ©ã‚¤ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚</p>';
        return;
      }

      // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
      let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px;">';

      rimeArray.forEach(item => {
        const rate = parseFloat(item.rate);
        let bgColor, textColor;

        if (rate < 50) {
          bgColor = '#ffcdd2'; // èµ¤
          textColor = '#c62828';
        } else if (rate < 70) {
          bgColor = '#ffe0b2'; // ã‚ªãƒ¬ãƒ³ã‚¸
          textColor = '#e65100';
        } else if (rate < 90) {
          bgColor = '#fff9c4'; // é»„è‰²
          textColor = '#f57f17';
        } else {
          bgColor = '#c8e6c9'; // ç·‘
          textColor = '#2e7d32';
        }

        html += `
          <div style="
            background-color: ${bgColor};
            border: 2px solid ${textColor};
            border-radius: 8px;
            padding: 15px;
            text-align: center;
          ">
            <div style="font-size: 26px; font-weight: bold; color: ${textColor}; margin-bottom: 8px;">
              ${item.rime}
            </div>
            <div style="font-size: 28px; font-weight: bold; color: ${textColor}; margin-bottom: 5px;">
              ${item.rate}%
            </div>
            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">
              ${item.success}/${item.total}å›æ­£è§£
            </div>
            <div style="font-size: 11px; color: #888; font-style: italic;">
              ä¾‹: ${item.words}
            </div>
          </div>
        `;
      });

      html += '</div>';
      container.innerHTML = html;
    }
  </script>
</body>
</html>
